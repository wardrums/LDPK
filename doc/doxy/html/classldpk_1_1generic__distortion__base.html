<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>ldpk: ldpk::generic_distortion_base&lt; VEC2, MAT2, N &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ldpk"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ldpk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceldpk.html">ldpk</a></li><li class="navelem"><a class="el" href="classldpk_1_1generic__distortion__base.html">generic_distortion_base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classldpk_1_1generic__distortion__base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ldpk::generic_distortion_base&lt; VEC2, MAT2, N &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for a distortion model with N parameters. You may find it useful to derive your own distortion model class from this one. It contains methods for inverting the distortion model function. We derive this class from the standard unary function class in order to get a well-defined function object.  
 <a href="classldpk_1_1generic__distortion__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ldpk__generic__distortion__base_8h_source.html">ldpk_generic_distortion_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ldpk::generic_distortion_base&lt; VEC2, MAT2, N &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classldpk_1_1generic__distortion__base__inherit__graph.png" border="0" usemap="#ldpk_1_1generic__distortion__base_3_01VEC2_00_01MAT2_00_01N_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="ldpk_1_1generic__distortion__base_3_01VEC2_00_01MAT2_00_01N_01_4_inherit__map" id="ldpk_1_1generic__distortion__base_3_01VEC2_00_01MAT2_00_01N_01_4_inherit__map">
<area shape="rect" id="node3" href="classldpk_1_1generic__radial__distortion.html" title="A polynomial model with N coefficients for radially symmetric lenses. This class contains the model f..." alt="" coords="5,187,208,229"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ldpk::generic_distortion_base&lt; VEC2, MAT2, N &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classldpk_1_1generic__distortion__base__coll__graph.png" border="0" usemap="#ldpk_1_1generic__distortion__base_3_01VEC2_00_01MAT2_00_01N_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="ldpk_1_1generic__distortion__base_3_01VEC2_00_01MAT2_00_01N_01_4_coll__map" id="ldpk_1_1generic__distortion__base_3_01VEC2_00_01MAT2_00_01N_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a229cd936e884e5931211ec93f845e3ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229cd936e884e5931211ec93f845e3ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a229cd936e884e5931211ec93f845e3ba">get_num_parameters</a> () const </td></tr>
<tr class="memdesc:a229cd936e884e5931211ec93f845e3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of parameters, that is N. <br /></td></tr>
<tr class="separator:a229cd936e884e5931211ec93f845e3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ce7793245603a1d3f1dc22485333fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ce7793245603a1d3f1dc22485333fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a38ce7793245603a1d3f1dc22485333fd">setup_map_inverse</a> (int n_max_iter, int n_post_iter, double epsilon)</td></tr>
<tr class="memdesc:a38ce7793245603a1d3f1dc22485333fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure iterative procedure for <a class="el" href="classldpk_1_1generic__distortion__base.html#a8b1ca00e2841c323988ec5c137bcb6f6" title="Inverse mapping by solving the fixed point equation without providing initial values. Virtual, because the derived class might use some smart data structure for calculating an initial value. ">map_inverse()</a>. Call this, if you don't agree with the default values. <br /></td></tr>
<tr class="separator:a38ce7793245603a1d3f1dc22485333fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1ac288e478370331fe7cef5213d61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aa1ac288e478370331fe7cef5213d61"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a8aa1ac288e478370331fe7cef5213d61">done</a> ()</td></tr>
<tr class="memdesc:a8aa1ac288e478370331fe7cef5213d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">After changing one or more coefficients of the model, call this (future use). The derived class may prepare some data structure for fast/precise evalutation.. <br /></td></tr>
<tr class="separator:a8aa1ac288e478370331fe7cef5213d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2602bada8d14384c7cc78fe2dce03be5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2602bada8d14384c7cc78fe2dce03be5"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a2602bada8d14384c7cc78fe2dce03be5">get_coeff</a> (int i) const =0</td></tr>
<tr class="memdesc:a2602bada8d14384c7cc78fe2dce03be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">There must be methods to address coefficients by one single index i in [0,N[. <br /></td></tr>
<tr class="separator:a2602bada8d14384c7cc78fe2dce03be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee72c76e418aadc5286e1cb620a881"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62ee72c76e418aadc5286e1cb620a881"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_coeff</b> (int i, double)=0</td></tr>
<tr class="separator:a62ee72c76e418aadc5286e1cb620a881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d6ff19d03027c1c301c3fd8ff80c37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d6ff19d03027c1c301c3fd8ff80c37"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#ad2d6ff19d03027c1c301c3fd8ff80c37">reset_k_max_iter</a> ()</td></tr>
<tr class="memdesc:ad2d6ff19d03027c1c301c3fd8ff80c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset k_max_iter for debugging purposes. <br /></td></tr>
<tr class="separator:ad2d6ff19d03027c1c301c3fd8ff80c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6cd79d8a78afcbc789c96013eeed14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6cd79d8a78afcbc789c96013eeed14"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a3f6cd79d8a78afcbc789c96013eeed14">get_k_iter</a> () const </td></tr>
<tr class="memdesc:a3f6cd79d8a78afcbc789c96013eeed14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of iterations until epsilon was reached. This value is reset at the beginning of each iterative calculation. <br /></td></tr>
<tr class="separator:a3f6cd79d8a78afcbc789c96013eeed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade018102f0fecb2175520b5838167b69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade018102f0fecb2175520b5838167b69"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#ade018102f0fecb2175520b5838167b69">get_k_max_iter</a> () const </td></tr>
<tr class="memdesc:ade018102f0fecb2175520b5838167b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">By this value you can check how much iterations per pixel were required to warp an entire image or sequence. Use <a class="el" href="classldpk_1_1generic__distortion__base.html#ad2d6ff19d03027c1c301c3fd8ff80c37" title="Reset k_max_iter for debugging purposes. ">reset_k_max_iter()</a> to reset to 0. <br /></td></tr>
<tr class="separator:ade018102f0fecb2175520b5838167b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932a47fbbcacecef795629638aa6cd1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a932a47fbbcacecef795629638aa6cd1b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a932a47fbbcacecef795629638aa6cd1b">get_n_max_iter</a> () const </td></tr>
<tr class="memdesc:a932a47fbbcacecef795629638aa6cd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined maximum number of iterations applied in map_inverse in order to fulfill the termination condition. <br /></td></tr>
<tr class="separator:a932a47fbbcacecef795629638aa6cd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4c02a8de6a7855e074d864e80d43f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd4c02a8de6a7855e074d864e80d43f9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#abd4c02a8de6a7855e074d864e80d43f9">get_n_post_iter</a> () const </td></tr>
<tr class="memdesc:abd4c02a8de6a7855e074d864e80d43f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined number of additional iterations to be applied when the termination condition is fulfilled (which we call post-iterations). <br /></td></tr>
<tr class="separator:abd4c02a8de6a7855e074d864e80d43f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad758c4cf288e1b01183b7400ca524eea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad758c4cf288e1b01183b7400ca524eea"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#ad758c4cf288e1b01183b7400ca524eea">get_diff</a> () const </td></tr>
<tr class="memdesc:ad758c4cf288e1b01183b7400ca524eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference between is-value and should-be-value in <a class="el" href="classldpk_1_1generic__distortion__base.html#a8b1ca00e2841c323988ec5c137bcb6f6" title="Inverse mapping by solving the fixed point equation without providing initial values. Virtual, because the derived class might use some smart data structure for calculating an initial value. ">map_inverse()</a>. Inverse mapping is implemented as fixed-point problem. <a class="el" href="classldpk_1_1generic__distortion__base.html#a8b1ca00e2841c323988ec5c137bcb6f6" title="Inverse mapping by solving the fixed point equation without providing initial values. Virtual, because the derived class might use some smart data structure for calculating an initial value. ">map_inverse()</a> terminates, when diff is smaller than epsilon or the number of iterations exceeds n_max_iter. <br /></td></tr>
<tr class="separator:ad758c4cf288e1b01183b7400ca524eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43126dff03b4255b924deb17d81048c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af43126dff03b4255b924deb17d81048c"></a>
virtual vec2_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#af43126dff03b4255b924deb17d81048c">operator()</a> (const vec2_type &amp;p) const =0</td></tr>
<tr class="memdesc:af43126dff03b4255b924deb17d81048c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove distortion. This method is non-iterative. <br /></td></tr>
<tr class="separator:af43126dff03b4255b924deb17d81048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d7c9c262f3d86e2f84b2bad040dff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a196d7c9c262f3d86e2f84b2bad040dff"></a>
vec2_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a196d7c9c262f3d86e2f84b2bad040dff">eval</a> (const vec2_type &amp;p) const </td></tr>
<tr class="memdesc:a196d7c9c262f3d86e2f84b2bad040dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as method instead of operator. <br /></td></tr>
<tr class="separator:a196d7c9c262f3d86e2f84b2bad040dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aab6823d51dcc13dd5e9e4fe578472a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aab6823d51dcc13dd5e9e4fe578472a"></a>
virtual mat2_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a3aab6823d51dcc13dd5e9e4fe578472a">jacobi</a> (const vec2_type &amp;p_dn) const </td></tr>
<tr class="memdesc:a3aab6823d51dcc13dd5e9e4fe578472a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi-Matrix. The result is a matrix g_{ij} = d/dp_j f(p)_i, where f represents the undistort-function. We compute this by means of difference quotients. This requires four evaluations. For better performance, you can implement the analytic form in your derived distortion class. <br /></td></tr>
<tr class="separator:a3aab6823d51dcc13dd5e9e4fe578472a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f4cebf0d524236efd8dd2d0d4248b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5f4cebf0d524236efd8dd2d0d4248b8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#af5f4cebf0d524236efd8dd2d0d4248b8">derive</a> (double *dg, int n_parameters, const vec2_type &amp;p_dn) const </td></tr>
<tr class="memdesc:af5f4cebf0d524236efd8dd2d0d4248b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not all distortion functions will support this. <br /></td></tr>
<tr class="separator:af5f4cebf0d524236efd8dd2d0d4248b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1ca00e2841c323988ec5c137bcb6f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b1ca00e2841c323988ec5c137bcb6f6"></a>
virtual vec2_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a8b1ca00e2841c323988ec5c137bcb6f6">map_inverse</a> (const vec2_type &amp;q) const </td></tr>
<tr class="memdesc:a8b1ca00e2841c323988ec5c137bcb6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse mapping by solving the fixed point equation without providing initial values. Virtual, because the derived class might use some smart data structure for calculating an initial value. <br /></td></tr>
<tr class="separator:a8b1ca00e2841c323988ec5c137bcb6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec27818a3c8d6c9f05ae0593500e9c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abec27818a3c8d6c9f05ae0593500e9c3"></a>
vec2_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#abec27818a3c8d6c9f05ae0593500e9c3">map_inverse</a> (const vec2_type &amp;q, const vec2_type &amp;p_start) const </td></tr>
<tr class="memdesc:abec27818a3c8d6c9f05ae0593500e9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">For given q, we are looking for p so that f(p) = q. p_start is near to p. <br /></td></tr>
<tr class="separator:abec27818a3c8d6c9f05ae0593500e9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1850d21844a48f54464a1a5c765065c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1850d21844a48f54464a1a5c765065c3"></a>
virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a1850d21844a48f54464a1a5c765065c3">out</a> (std::ostream &amp;cout) const </td></tr>
<tr class="memdesc:a1850d21844a48f54464a1a5c765065c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The derived class implements a method for printing values inside 3DE4's matrix tool dialog. This functionality is currently not supported by <a class="el" href="classtde4__ld__plugin.html" title="Lens Distortion Plugin Base Class. ">tde4_ld_plugin</a>. <br /></td></tr>
<tr class="separator:a1850d21844a48f54464a1a5c765065c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0d6b840b01d833c31b84eaec4b1541b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d6b840b01d833c31b84eaec4b1541b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classldpk_1_1generic__distortion__base.html#a0d6b840b01d833c31b84eaec4b1541b8">check_range</a> (int i) const </td></tr>
<tr class="memdesc:a0d6b840b01d833c31b84eaec4b1541b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived class may check if the index is valid. <br /></td></tr>
<tr class="separator:a0d6b840b01d833c31b84eaec4b1541b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class VEC2, class MAT2, int N&gt;<br />
class ldpk::generic_distortion_base&lt; VEC2, MAT2, N &gt;</h3>

<p>Base class for a distortion model with N parameters. You may find it useful to derive your own distortion model class from this one. It contains methods for inverting the distortion model function. We derive this class from the standard unary function class in order to get a well-defined function object. </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>/server/devel/sdv/privat/uwe/source/ldpk/include/ldpk/<a class="el" href="ldpk__generic__distortion__base_8h_source.html">ldpk_generic_distortion_base.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 29 2016 16:34:30 for ldpk by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
